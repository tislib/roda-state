use std::collections::HashMap;
use std::path::PathBuf;
use std::time::Instant;

use bytemuck::{Pod, Zeroable};
use clap::Parser;
use dbn::decode::{DbnDecoder as Decoder, DbnMetadata, DecodeRecordRef};
use dbn::enums::{Action, rtype, Side, SType};
use dbn::record::MboMsg;
use dbn::Record;
use dbn::SymbolIndex;

// Use your specific high-level API modules
use roda_state::components::{Engine, Store, StoreOptions, StoreReader};
use roda_state::{RodaEngine, Window};

// ==============================================================================
// 1. DATA CONTRACT
// ==============================================================================

/// The normalized "Top of Book" update.
#[repr(C)]
#[derive(Debug, Clone, Copy, Default, Pod, Zeroable)]
pub struct BboUpdate {
    pub ts: u64,
    pub instrument_id: u32,
    pub _pad0: u32,
    pub bid_px: i64,
    pub ask_px: i64,
    pub bid_sz: u32,
    pub ask_sz: u32,
}

/// The output signal generated by the strategy.
#[repr(C)]
#[derive(Debug, Clone, Copy, Default, Pod, Zeroable)]
pub struct TradeSignal {
    pub ts: u64,
    pub instrument_id: u32,
    pub signal_strength: f32, // > 0.8 is Buy
    pub is_buy: i32,          // 1 = Buy, -1 = Sell
    pub _pad0: i32,
}

struct OrderInfo {
    price: i64,
    size: u32,
    is_bid: bool,
}

#[derive(Parser)]
struct Args {
    #[arg(long)]
    file: PathBuf,
    #[arg(long, default_value = "NVDA")]
    symbol: String,
}

// ==============================================================================
// 2. THE PIPELINE IMPLEMENTATION
// ==============================================================================

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    println!("[System] Booting Roda Showcase (Declarative Mode)...");

    let engine = RodaEngine::new();

    // A. RESOURCES
    // --------------------------------------------------------------------------
    // 1. Market Data Store (The "River" of BBO updates)
    let mut market_store = engine.store::<BboUpdate>(StoreOptions {
        name: "market_data",
        size: 10_000_000,
        in_memory: true,
    });
    let market_reader = market_store.reader();

    // We create an index to look up BBO by Instrument ID
    let _market_index = market_store.direct_index::<u32>();

    // 2. Signal Store (The Output of our Strategy)
    let mut signal_store = engine.store::<TradeSignal>(StoreOptions {
        name: "signals",
        size: 10_000,
        in_memory: true,
    });
    // We don't read signals in this example, but we could
    let _signal_reader = signal_store.reader();

    // B. PIPELINES
    // --------------------------------------------------------------------------
    // Strategy Pipeline: Look at the last 1 tick (Current) to calculate imbalance
    // In a real strategy, we might look at a window of 5.
    let strategy_pipeline: Window<BboUpdate, TradeSignal> = Window::new();

    // C. WORKERS
    // --------------------------------------------------------------------------

    // --- WORKER 1: STRATEGY ENGINE ---
    // This runs in a background thread managed by RodaEngine
    engine.run_worker(move || {
        // 1. Drive the reader
        market_reader.next();

        // 2. Execute Pipeline
        strategy_pipeline
            .from(&market_reader)
            .to(&mut signal_store)
            .reduce(1, |window| {
                // Window size 1 means window[0] is the current item
                let bbo = &window[0];

                // Logic: Calculate Book Imbalance
                let bid_vol = bbo.bid_sz as f32;
                let ask_vol = bbo.ask_sz as f32;
                let total_vol = bid_vol + ask_vol;

                if total_vol > 0.0 {
                    let imbalance = (bid_vol - ask_vol) / total_vol;

                    // Signal Logic: Strong Buy Imbalance (> 0.8)
                    if imbalance > 0.8 {
                        return Some(TradeSignal {
                            ts: bbo.ts,
                            instrument_id: bbo.instrument_id,
                            signal_strength: imbalance,
                            is_buy: 1,
                            _pad0: 0,
                        });
                    }
                }
                None
            });
    });

    // --- WORKER 2: FEED HANDLER (The Data Source) ---
    // Since this reads from a File (Zstd) and not a Roda Store,
    // we run it as the "Driver" on the main thread (or a separate spawn).
    // It acts as the Producer for 'market_store'.

    println!("[Writer] Starting Feed Handler for {:?}...", args.file);
    let start = Instant::now();
    let mut count = 0u64;

    // 1. Setup Decoder
    let mut decoder = Decoder::from_zstd_file(&args.file)?;

    // 2. Resolve Symbology
    let metadata = decoder.metadata();
    // Prefer robust mapping using metadata symbol map for the start date
    let date = metadata.start().date();
    let pit_map = metadata.symbol_map_for_date(date)?;
    // Find instrument_id for the requested symbol
    let mut target_id_opt = pit_map
        .inner()
        .iter()
        .find_map(|(iid, sym)| if sym == &args.symbol { Some(*iid) } else { None });

    if target_id_opt.is_none() {
        // Fallback: resolve via mappings depending on stype_in/out
        target_id_opt = match (metadata.stype_in, metadata.stype_out) {
            (Some(SType::RawSymbol), SType::InstrumentId) => metadata
                .mappings
                .iter()
                .find(|m| m.raw_symbol == args.symbol)
                .and_then(|m| m.intervals.first())
                .and_then(|i| i.symbol.parse::<u32>().ok()),
            (Some(SType::InstrumentId), SType::RawSymbol) => metadata
                .mappings
                .iter()
                .find_map(|m| {
                    if m.intervals.iter().any(|iv| iv.symbol == args.symbol) {
                        m.raw_symbol.parse::<u32>().ok()
                    } else {
                        None
                    }
                }),
            _ => None,
        };
    }

    // Final fallback: if still not found, try instrument defs; if still not found, pick first symbol in map
    let (target_id, resolved_symbol) = if let Some(id) = target_id_opt {
        (id, args.symbol.clone())
    } else {
        let mut resolver = Decoder::from_zstd_file(&args.file)?;
        let mut found: Option<u32> = None;
        while let Some(rec) = resolver.decode_record_ref()? {
            if rec.header().rtype == rtype::INSTRUMENT_DEF {
                if let Ok(def) = rec.try_get::<dbn::record::InstrumentDefMsg>() {
                    if let Ok(sym) = dbn::record::c_chars_to_str(&def.raw_symbol) {
                        if sym == args.symbol {
                            found = Some(def.hd.instrument_id);
                            break;
                        }
                    }
                }
            }
        }
        if let Some(id) = found {
            (id, args.symbol.clone())
        } else {
            // Last resort: pick first available symbol from the map
            if let Some((iid, sym)) = pit_map.inner().iter().next() {
                eprintln!(
                    "[Writer] Warning: symbol '{}' not found. Falling back to '{}' (iid={}).",
                    args.symbol, sym, iid
                );
                (*iid, sym.clone())
            } else {
                panic!("Symbol not found and no mappings available")
            }
        }
    };

    println!("[Writer] Mapped {} -> ID {}", resolved_symbol, target_id);

    // 3. Local State (Order Book Reconstruction)
    let mut book = HashMap::<u64, OrderInfo>::new();
    let mut last_bbo = (0i64, i64::MAX); // Bid, Ask

    // 4. Hot Loop
    while let Some(record) = decoder.decode_record_ref()? {
        if record.header().rtype != rtype::MBO {
            continue;
        }

        let msg = record.get::<MboMsg>().unwrap();
        if msg.hd.instrument_id != target_id {
            continue;
        }

        let action = Action::try_from(msg.action as u8).unwrap_or(Action::None);
        let side = Side::try_from(msg.side as u8).unwrap_or(Side::None);

        // Update Local Book
        let mut changed = false;
        match action {
            Action::Add => {
                book.insert(
                    msg.order_id,
                    OrderInfo {
                        price: msg.price,
                        size: msg.size,
                        is_bid: side == Side::Bid,
                    },
                );
                changed = true;
            }
            Action::Cancel | Action::Fill => {
                book.remove(&msg.order_id);
                changed = true;
            }
            Action::Modify => {
                if let Some(o) = book.get_mut(&msg.order_id) {
                    o.price = msg.price;
                    o.size = msg.size;
                    changed = true;
                }
            }
            _ => {}
        }

        // Compute BBO and Push to Roda Store
        if changed {
            let (bid, ask, b_sz, a_sz) = compute_bbo(&book);

            if bid != last_bbo.0 || ask != last_bbo.1 {
                let update = BboUpdate {
                    ts: msg.hd.ts_event,
                    instrument_id: target_id,
                    bid_px: bid,
                    ask_px: ask,
                    bid_sz: b_sz,
                    ask_sz: a_sz,
                    _pad0: 0,
                };
                market_store.push(update);
                last_bbo = (bid, ask);
                count += 1;
            }
        }
    }

    let duration = start.elapsed();
    println!(
        "[Writer] Finished! Pushed {} updates in {:?}",
        count, duration
    );

    Ok(())
}

fn compute_bbo(book: &HashMap<u64, OrderInfo>) -> (i64, i64, u32, u32) {
    let mut best_bid = 0;
    let mut bid_sz = 0;
    let mut best_ask = i64::MAX;
    let mut ask_sz = 0;

    for info in book.values() {
        if info.is_bid {
            if info.price > best_bid {
                best_bid = info.price;
                bid_sz = info.size;
            } else if info.price == best_bid {
                bid_sz += info.size;
            }
        } else {
            if info.price < best_ask {
                best_ask = info.price;
                ask_sz = info.size;
            } else if info.price == best_ask {
                ask_sz += info.size;
            }
        }
    }

    if best_ask == i64::MAX {
        best_ask = 0;
    }

    (best_bid, best_ask, bid_sz, ask_sz)
}