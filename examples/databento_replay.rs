use std::collections::HashMap;
use std::path::PathBuf;
use std::time::Instant;

use bytemuck::{Pod, Zeroable};
use clap::Parser;
use dbn::decode::{DbnDecoder as Decoder, DecodeRecordRef};
use dbn::enums::{Action, rtype, Side};
use dbn::record::MboMsg;
use dbn::Record;

// Use your specific high-level API modules
use roda_state::components::{Engine, Index, Store, StoreOptions, StoreReader};
use roda_state::{RodaEngine, Window};

// ==============================================================================
// 1. DATA CONTRACT
// ==============================================================================

/// The normalized "Top of Book" update.
#[repr(C)]
#[derive(Debug, Clone, Copy, Default, Pod, Zeroable)]
pub struct BboUpdate {
    pub ts: u64,
    pub instrument_id: u32,
    pub _pad0: u32,
    pub bid_px: i64,
    pub ask_px: i64,
    pub bid_sz: u32,
    pub ask_sz: u32,
}

/// The output signal generated by the strategy.
#[repr(C)]
#[derive(Debug, Clone, Copy, Default, Pod, Zeroable)]
pub struct TradeSignal {
    pub ts: u64,
    pub instrument_id: u32,
    pub signal_strength: f32, // > 0.8 is Buy
    pub is_buy: i32,          // 1 = Buy, -1 = Sell
    pub _pad0: i32,
}

struct OrderInfo {
    price: i64,
    size: u32,
    is_bid: bool,
}

#[derive(Parser)]
struct Args {
    #[arg(long)]
    file: PathBuf,
}

// ==============================================================================
// 2. THE PIPELINE IMPLEMENTATION
// ==============================================================================

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    println!("[System] Booting Roda Showcase (Declarative Mode)...");

    let mut engine = RodaEngine::new();

    // A. RESOURCES
    // --------------------------------------------------------------------------
    // 1. Market Data Store (The "River" of BBO updates)
    let mut market_store = engine.store::<BboUpdate>(StoreOptions {
        name: "market_data",
        size: 10_000_000,
        in_memory: true,
    });
    let market_reader = market_store.reader();

    // We create an index to look up BBO by Instrument ID
    // We will use this for partitioning later
    // let _market_index = market_store.direct_index::<u32>();

    // 2. Signal Store (The Output of our Strategy)
    let mut signal_store = engine.store::<TradeSignal>(StoreOptions {
        name: "signals",
        size: 10_000,
        in_memory: true,
    });
    // We don't read signals in this example, but we could
    let _signal_reader = signal_store.reader();

    // B. PIPELINES
    // --------------------------------------------------------------------------
    // Strategy Pipeline: Look at the last 1 tick (Current) to calculate imbalance
    // In a real strategy, we might look at a window of 5.
    let strategy_pipeline: Window<BboUpdate, TradeSignal> = Window::new();

    // C. WORKERS
    // --------------------------------------------------------------------------

    // --- WORKER 1: STRATEGY ENGINE ---
    // This runs in a background thread managed by RodaEngine
    engine.run_worker(move || {
        // 1. Drive the reader
        market_reader.next();

        // 2. Execute Pipeline
        strategy_pipeline
            .from(&market_reader)
            .to(&mut signal_store)
            .reduce(1, |window| {
                // Window size 1 means window[0] is the current item
                let bbo = &window[0];

                // Logic: Calculate Book Imbalance
                let bid_vol = bbo.bid_sz as f32;
                let ask_vol = bbo.ask_sz as f32;
                let total_vol = bid_vol + ask_vol;

                if total_vol > 0.0 {
                    let imbalance = (bid_vol - ask_vol) / total_vol;

                    // Signal Logic: Strong Buy Imbalance (> 0.8)
                    if imbalance > 0.8 {
                        return Some(TradeSignal {
                            ts: bbo.ts,
                            instrument_id: bbo.instrument_id,
                            signal_strength: imbalance,
                            is_buy: 1,
                            _pad0: 0,
                        });
                    }
                }
                None
            });
    });

    // 3. Partitioning: we can use direct index to partition by symbol
    let market_index = market_store.direct_index::<u32>();
    engine.run_worker(move || {
        market_index.compute(|bbo| bbo.instrument_id);
    });

    // --- WORKER 2: FEED HANDLER (The Data Source) ---
    // Since this reads from a File (Zstd) and not a Roda Store,
    // we run it as the "Driver" on the main thread (or a separate spawn).
    // It acts as the Producer for 'market_store'.

    println!("[Writer] Starting Feed Handler for {:?}...", args.file);
    let start = Instant::now();
    let mut count = 0u64;

    // 1. Setup Decoder
    let mut decoder = Decoder::from_zstd_file(&args.file)?;

    // 3. Local State (Order Book Reconstruction)
    let mut books = HashMap::<u32, HashMap<u64, OrderInfo>>::new();
    let mut last_bbos = HashMap::<u32, (i64, i64)>::new(); // instrument_id -> (Bid, Ask)

    // 4. Hot Loop
    while let Some(record) = decoder.decode_record_ref()? {
        if record.header().rtype != rtype::MBO {
            continue;
        }

        let msg = record.get::<MboMsg>().unwrap();
        let instrument_id = msg.hd.instrument_id;

        let book = books.entry(instrument_id).or_default();
        let last_bbo = last_bbos.entry(instrument_id).or_insert((0i64, i64::MAX));

        let action = Action::try_from(msg.action as u8).unwrap_or(Action::None);
        let side = Side::try_from(msg.side as u8).unwrap_or(Side::None);

        // Update Local Book
        let mut changed = false;
        match action {
            Action::Add => {
                book.insert(
                    msg.order_id,
                    OrderInfo {
                        price: msg.price,
                        size: msg.size,
                        is_bid: side == Side::Bid,
                    },
                );
                changed = true;
            }
            Action::Cancel | Action::Fill => {
                book.remove(&msg.order_id);
                changed = true;
            }
            Action::Modify => {
                if let Some(o) = book.get_mut(&msg.order_id) {
                    o.price = msg.price;
                    o.size = msg.size;
                    changed = true;
                }
            }
            _ => {}
        }

        // Compute BBO and Push to Roda Store
        if changed {
            let (bid, ask, b_sz, a_sz) = compute_bbo(book);

            if bid != last_bbo.0 || ask != last_bbo.1 {
                let update = BboUpdate {
                    ts: msg.hd.ts_event,
                    instrument_id,
                    bid_px: bid,
                    ask_px: ask,
                    bid_sz: b_sz,
                    ask_sz: a_sz,
                    _pad0: 0,
                };
                market_store.push(update);
                *last_bbo = (bid, ask);
                count += 1;
            }
        }
    }

    let duration = start.elapsed();
    println!(
        "[Writer] Finished! Pushed {} updates in {:?}",
        count, duration
    );

    Ok(())
}

fn compute_bbo(book: &HashMap<u64, OrderInfo>) -> (i64, i64, u32, u32) {
    let mut best_bid = 0;
    let mut bid_sz = 0;
    let mut best_ask = i64::MAX;
    let mut ask_sz = 0;

    for info in book.values() {
        if info.is_bid {
            if info.price > best_bid {
                best_bid = info.price;
                bid_sz = info.size;
            } else if info.price == best_bid {
                bid_sz += info.size;
            }
        } else {
            if info.price < best_ask {
                best_ask = info.price;
                ask_sz = info.size;
            } else if info.price == best_ask {
                ask_sz += info.size;
            }
        }
    }

    if best_ask == i64::MAX {
        best_ask = 0;
    }

    (best_bid, best_ask, bid_sz, ask_sz)
}